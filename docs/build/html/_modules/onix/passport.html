

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>onix.passport &mdash; ONIX Documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #0d0d0d" >
          

          
            <a href="../../index.html">
          

          
            
            <img src="../../_static/logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview of ONIX</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../releasenotes/index.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pythonapi/index.html">Python API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">License Agreement</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">ONIX</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>onix.passport</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for onix.passport</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot; This module defines the Python class passport used in ONIX&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">math</span> <span class="k">as</span> <span class="nn">m</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">data</span> <span class="k">as</span> <span class="n">d</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">functions</span> <span class="k">as</span> <span class="n">fct</span>

<div class="viewcode-block" id="Passport"><a class="viewcode-back" href="../../pythonapi/generated/onix.Passport.html#onix.Passport">[docs]</a><span class="k">class</span> <span class="nc">Passport</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Passport stores all the relevant data of indivudual nuclides and offers methods to extract information on them.</span>

<span class="sd">       The passport class is individually instantiated for each nuclide. It contains two types of information: constant and variable data.</span>
<span class="sd">       Constant data, such as the atomic mass, decay constant or the element&#39;s family (actinide or fission products) do not change over the course of a simulation.</span>
<span class="sd">       Variable data such as cross sections or fission yields do vary during a simulation and need to be updated regularly during a simulation.</span>
<span class="sd">       Some of the data are created at the time of the instantiation of the class such as the element&#39;s family or the nuclide&#39;s</span>
<span class="sd">       neutron reaction daughters. Other type of data, typically large in size such as cross sections and decay constants, are to be explicitly set or loaded by the code or by the user.</span>

<span class="sd">       Parameters</span>
<span class="sd">       ----------</span>
<span class="sd">       nuc_id : str</span>
<span class="sd">            Name or z-a-m id of the nuclide.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_mass</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_fission_E</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">_name</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_zamid</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1">#_allreacs_dic_list = [] # A list of dicts of all the creation and destruction terms at eacch sequence point</span>


    <span class="c1"># Number id of the nuclide for which a passport is instantiated</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nuc_id</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nuc_id</span> <span class="o">=</span> <span class="n">nuc_id</span> <span class="c1"># probably useless</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_id_input_type</span><span class="p">(</span><span class="n">nuc_id</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;name&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nuc_id</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_zamid</span> <span class="o">=</span> <span class="n">fct</span><span class="o">.</span><span class="n">name_to_zamid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_id_input_type</span><span class="p">(</span><span class="n">nuc_id</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;zamid&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_zamid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nuc_id</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">fct</span><span class="o">.</span><span class="n">zamid_to_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_zamid</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_state</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_xschild</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_decaychild</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_xsparent</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_decayparent</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_all_parent</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_all_child</span><span class="p">()</span>
        <span class="c1"># self._all_non0_child = self.get_all_non0_child()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_all_reacs_dic</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_allreacs_dic_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__current_sorted_allreacs_tuple_list</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sorted_allreacs_tuple_mat</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_current_dens</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dens_seq</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_dens_subseq</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dens_subseq_mat</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_current_xs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xs_seq</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decay_a</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decay_b</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fy</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_FAM</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;ACT&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_energy_per_fission</span><span class="p">()</span>





    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mass</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the atomic mass of the nuclide in grams&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mass</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># define exception for undefined variable</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mass</span>

    <span class="nd">@mass</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">mass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_mass</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the atomic mass of the nuclide in grams&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_mass</span> <span class="o">=</span> <span class="n">new_mass</span>    

    <span class="c1"># Passport instantiation will read and extract by itself mass for the corresponding nuclide</span>
<div class="viewcode-block" id="Passport.load_mass"><a class="viewcode-back" href="../../pythonapi/generated/onix.Passport.html#onix.Passport.load_mass">[docs]</a>    <span class="k">def</span> <span class="nf">load_mass</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Loads the atomic mass of the nuclide in gram.</span>

<span class="sd">        This method directly fetches the atomic mass from the mass library and automatically sets it</span>
<span class="sd">        to the passport object&quot;&quot;&quot;</span>

        <span class="n">zamid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zamid</span>
        <span class="n">zaid</span> <span class="o">=</span> <span class="n">zamid</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Some (rare) nuclides (for example Ag133 from ENDFVIII) are not in the mass library</span>
        <span class="c1"># For these nuclides, the mass number is used for the mass</span>
        <span class="k">if</span> <span class="n">zaid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">default_atm_mass_lib</span><span class="p">:</span>
            <span class="n">mass</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">zaid</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">mass</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">default_atm_mass_lib</span><span class="p">[</span><span class="n">zaid</span><span class="p">]</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">_mass</span> <span class="o">=</span> <span class="n">mass</span></div>



    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">decay_a</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the absolute values of the decay constant of the nuclide&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decay_a</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># define exception for undefined variable</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decay_a</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">decay_b</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the fraction percent values of the decay constant of the nuclide&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decay_b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># define exception for undefined variable</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decay_b</span>

    <span class="nd">@decay_a</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">decay_a</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_decay_a</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the absolute values of the decay constant of the nuclide&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_decay_a</span> <span class="o">=</span>  <span class="n">new_decay_a</span>

    <span class="nd">@decay_b</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">decay_b</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_decay_b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the fraction percent values of the decay constant of the nuclide&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decay_b</span> <span class="o">=</span>  <span class="n">new_decay_b</span>

<div class="viewcode-block" id="Passport.set_decay"><a class="viewcode-back" href="../../pythonapi/generated/onix.Passport.html#onix.Passport.set_decay">[docs]</a>    <span class="k">def</span> <span class="nf">set_decay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decay_a</span><span class="p">,</span> <span class="n">decay_b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the absolute and fracional values of the decay constant of the nuclide&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decay_a</span> <span class="o">=</span>  <span class="n">decay_a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decay_b</span> <span class="o">=</span>  <span class="n">decay_b</span></div>

<div class="viewcode-block" id="Passport.load_decay"><a class="viewcode-back" href="../../pythonapi/generated/onix.Passport.html#onix.Passport.load_decay">[docs]</a>    <span class="k">def</span> <span class="nf">load_decay</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Loads the decay constant value of the nuclide.</span>

<span class="sd">        This method directly fetches the decay constant values (absolute and fractional) from the decay library and automatically sets it to the passport object&quot;&quot;&quot;</span>

        <span class="n">zamid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zamid</span>

        <span class="n">decay_a</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">default_decay_lib_a</span><span class="p">[</span><span class="n">zamid</span><span class="p">]</span>
        <span class="n">decay_b</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">default_decay_lib_b</span><span class="p">[</span><span class="n">zamid</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">decay_a</span> <span class="o">=</span> <span class="n">decay_a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decay_b</span> <span class="o">=</span> <span class="n">decay_b</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">current_xs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the current cross sections dictionnary of the nuclide&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_xs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># define exception for undefined variable</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_xs</span>

    <span class="nd">@current_xs</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">current_xs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_xs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the current cross sections dictionnary of the nuclide&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_xs</span> <span class="o">=</span> <span class="n">new_xs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xs_seq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the sequence of cross section dictionnaries of the nuclide&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xs_seq</span>

    <span class="nd">@xs_seq</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">xs_seq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_xs_seq</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the sequence of cross section dictionnaries of the nuclide&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xs_seq</span> <span class="o">=</span> <span class="n">new_xs_seq</span>

    <span class="k">def</span> <span class="nf">_append_xs_seq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_xs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Appends a new cross section dictionnary to the sequence of cross section dictionnaries&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xs_seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_xs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_xs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_xs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This method first verifies if a macro sequence of cross section dictionnaries has been already created for the nuclide.</span>
<span class="sd">        If not, it creates a sequence and append the new cross section dictionnary.</span>
<span class="sd">        If a sequence already exists, it just appends the new dictionnary to the already existing sequence&quot;&quot;&quot;</span>
        <span class="c1"># If this is the fist step</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_xs</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xs_seq</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_xs</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_append_xs_seq</span><span class="p">(</span><span class="n">new_xs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">current_xs</span> <span class="o">=</span> <span class="n">new_xs</span>
       <span class="c1"># self._append_time_subseq_mat()</span>

    <span class="k">def</span> <span class="nf">_overwrite_xs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_xs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This method first verifies if a macro sequence of cross section dictionnaries has been already created for the nuclide.</span>
<span class="sd">        If not, it creates a sequence and append the new cross section dictionnary.</span>
<span class="sd">        If a sequence already exists, it overwrites the last dictionnary with the new dictionnary in the already existing sequence&quot;&quot;&quot;</span>
       <span class="c1"># If this is the fist step</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_xs</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xs_seq</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_xs</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xs_seq</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_xs</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">current_xs</span> <span class="o">=</span> <span class="n">new_xs</span>
       <span class="c1"># self._append_time_subseq_mat()</span>


    <span class="c1"># Passport instantiation will read and extract by itself mass for the corresponding nuclide</span>
<div class="viewcode-block" id="Passport.load_xs"><a class="viewcode-back" href="../../pythonapi/generated/onix.Passport.html#onix.Passport.load_xs">[docs]</a>    <span class="k">def</span> <span class="nf">load_xs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Loads the cross sections data of the nuclide.</span>

<span class="sd">        This method directly fetches the cross sections data from the cross section library and automatically sets</span>
<span class="sd">        it to the passport object&quot;&quot;&quot;</span>

        <span class="n">zamid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zamid</span>
        <span class="n">xs_lib</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">default_xs_lib</span>
        <span class="n">xs</span> <span class="o">=</span> <span class="n">xs_lib</span><span class="p">[</span><span class="n">zamid</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_current_xs</span> <span class="o">=</span> <span class="n">xs</span></div>



    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the fission yields dictionnary.</span>

<span class="sd">        Fission yield dictionnary are defined per fission product. Each key of the dictionnary is the zamid of one of the </span>
<span class="sd">        fission parents and the corresponding entry is the fission yield normalized to 1 (value between 0 and 1)&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># define exception for undefined variable)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fy</span>

    <span class="nd">@fy</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">fy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_fy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the fission yields dictionnary to a nuclide</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        new_fy : dict</span>
<span class="sd">            Dictionnary of fission yields for a daughter nuclide</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_FAM</span> <span class="o">==</span> <span class="s1">&#39;ACT&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Not_a_Fission_Product</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> is not a FP and can&#39;t be given fission yields&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_zamid</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fy</span> <span class="o">=</span> <span class="n">new_fy</span>

    <span class="c1"># Passport instantiation will read and extract by itself mass for the corresponding nuclide</span>
<div class="viewcode-block" id="Passport.load_fy"><a class="viewcode-back" href="../../pythonapi/generated/onix.Passport.html#onix.Passport.load_fy">[docs]</a>    <span class="k">def</span> <span class="nf">load_fy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load the fission yields dictionnary of the nuclide</span>

<span class="sd">        This method directly fetches the fission yields data from the fission yield library and automatically sets</span>
<span class="sd">        it to the passport object</span>

<span class="sd">        If the nuclide for which the fission yields data are being loaded is not a fission product,</span>
<span class="sd">        the error onix.Not_a_Fission_Product will be raised&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_FAM</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;ACT&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Not_a_Fission_Product</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> is not a FP and can&#39;t be given fission yields&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_zamid</span><span class="p">))</span>

        <span class="n">zamid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zamid</span>
        <span class="n">fy_lib</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">default_fy_lib</span>
        <span class="n">fy</span> <span class="o">=</span> <span class="n">fy_lib</span><span class="p">[</span><span class="n">zamid</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_fy</span> <span class="o">=</span> <span class="n">fy</span></div>



    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">current_dens</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the current density of the nuclide in atom per :math:`cm^{3}`&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_dens</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># define exception for undefined variable</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_dens</span>

    <span class="nd">@current_dens</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">current_dens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_dens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the current density of the nuclide in atom per :math:`cm^{3}`&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_dens</span> <span class="o">=</span> <span class="n">new_dens</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dens_seq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the macro sequence of densities of the nuclide in atom per :math:`cm^{3}`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dens_seq</span>

    <span class="nd">@dens_seq</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">dens_seq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_dens_seq</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the macro sequence of densities of the nuclide in atom per :math:`cm^{3}`&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_dens_seq</span> <span class="o">=</span> <span class="n">new_dens_seq</span>

    <span class="k">def</span> <span class="nf">_append_dens_seq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_dens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Appends a new density value to the macro sequence of densities of the nuclide in atom per :math:`cm^{3}`&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dens_seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_dens</span><span class="p">)</span>

<div class="viewcode-block" id="Passport.get_current_dens_subseq"><a class="viewcode-back" href="../../pythonapi/generated/onix.Passport.html#onix.Passport.get_current_dens_subseq">[docs]</a>    <span class="k">def</span> <span class="nf">get_current_dens_subseq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the current micro sequence of densities (i.e. micro sequence corresponding to the current macro step)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dens_subseq_mat</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dens_subseq_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the list of micro sequences of densities (one per macro step)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dens_subseq_mat</span>

<div class="viewcode-block" id="Passport.get_dens_subseq"><a class="viewcode-back" href="../../pythonapi/generated/onix.Passport.html#onix.Passport.get_dens_subseq">[docs]</a>    <span class="k">def</span> <span class="nf">get_dens_subseq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the micro sequence of densities number s (i.e. micro sequence corresponding to the macro step number s)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dens_subseq_mat</span><span class="p">[</span><span class="n">s</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">_append_dens_subseq_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_dens</span><span class="p">,</span> <span class="n">ss</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets new density value to the list of micro sequences of densities</span>

<span class="sd">        If this is the first micro step, creates a new micro sequence&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ss</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dens_subseq_mat</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dens_subseq_mat</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_dens</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_initial_dens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_dens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets initial density&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_dens</span> <span class="o">=</span> <span class="n">new_dens</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dens_seq</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_dens</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dens_subseq_mat</span> <span class="o">=</span> <span class="p">[[</span><span class="n">new_dens</span><span class="p">]]</span>

    <span class="k">def</span> <span class="nf">_set_step_dens</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets a new density in the macro sequence of densities</span>

<span class="sd">        The current density is set to the new density</span>
<span class="sd">        The new density is appended to the macro sequence of densities&quot;&quot;&quot;</span>
        <span class="n">dens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dens</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_append_dens_seq</span><span class="p">(</span><span class="n">dens</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_substep_dens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dens</span><span class="p">,</span> <span class="n">ss</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets a new density in the micro sequence of densities</span>

<span class="sd">        The current density is set to the new density</span>
<span class="sd">        The new density is appended to the micro sequence of densities&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_dens</span> <span class="o">=</span> <span class="n">dens</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_append_dens_subseq_mat</span><span class="p">(</span><span class="n">dens</span><span class="p">,</span> <span class="n">ss</span><span class="p">)</span>
       




    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">zamid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the z-a-m-id of the nuclide&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zamid</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the name of the nuclide&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>


    <span class="k">def</span> <span class="nf">_get_xs_prod_from_dic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produces a dictionnary that contains the operations required to be done on the zamid number of the nuclide</span>
<span class="sd">        to obtain the zamid of nuclides produced by the different types of neutron-induced reaction&quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span>
        <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">xs_prod_from</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">xs_prod_fromS_toS</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">xs_prod_from</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">xs_prod_fromS_toX</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">state</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">xs_prod_from</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">xs_prod_fromX_toS</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">xs_prod_from</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">xs_prod_fromX_toX</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">xs_prod_from</span>

    <span class="k">def</span> <span class="nf">_get_decay_prod_from_dic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produces a dictionnary that contains the operations required to be done on the zamid number of the nuclide</span>
<span class="sd">        to obtain the zamid of nuclides produced by the different types of decay reaction&quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span>
        <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">decay_prod_from</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">decay_prod_fromS_toS</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">decay_prod_from</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">decay_prod_fromS_toX</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">state</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">decay_prod_from</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">decay_prod_fromX_toS</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">decay_prod_from</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">decay_prod_fromX_toX</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">decay_prod_from</span>

    <span class="k">def</span> <span class="nf">_get_xs_prod_to_dic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produces a dictionnary that contains the operations required to be done on the zamid number of other nuclides</span>
<span class="sd">        that produces the nuclide via different types of neutron-induced reaction&quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span>
        <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">xs_prod_to</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">xs_prod_fromS_toS</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">xs_prod_to</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">xs_prod_fromX_toS</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">state</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">xs_prod_to</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">xs_prod_fromS_toX</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">xs_prod_to</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">xs_prod_fromX_toX</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">xs_prod_to</span>

    <span class="k">def</span> <span class="nf">_get_decay_prod_to_dic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produces a dictionnary that contains the operations required to be done on the zamid number of other nuclides</span>
<span class="sd">        that produces the nuclide via different types of decay reaction&quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span>
        <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">decay_prod_to</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">decay_prod_fromS_toS</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">decay_prod_to</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">decay_prod_fromX_toS</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">state</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">decay_prod_to</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">decay_prod_fromS_toX</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">decay_prod_to</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">decay_prod_fromX_toX</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">decay_prod_to</span>



    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xs_child</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the daughter products of the nuclide via neutron-induced rections&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xs_child</span>    

    <span class="k">def</span> <span class="nf">_set_xschild</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">zamid</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_zamid</span><span class="p">)</span>

        <span class="n">xs_prod_from_dic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_xs_prod_from_dic</span><span class="p">()</span>
        
        <span class="n">child_dic</span> <span class="o">=</span> <span class="p">{}</span>
      
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xs_prod_from_dic</span><span class="p">:</span>

            <span class="c1"># If nuclide is Li6 or Be10, add children from (n,t)</span>
            <span class="c1"># (n,t) rxn rate only tallied for Li6 and Be10</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="s1">&#39;(n,t)&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">zamid</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">30060</span><span class="p">,</span> <span class="mi">50100</span><span class="p">]:</span>
                    <span class="c1"># In the case of (n,t) (and (n,alpha) as well), the reaction creates two new nuclides</span>
                    <span class="c1"># The reaction is thus branched out in two new reactions:</span>
                    <span class="c1"># 1) (n,x) which creates nuclides according to xs_prod_from_dic</span>
                    <span class="c1"># 2) (n,x)x which creates x, which is the particle emitted (tritium or alpha)</span>
                    <span class="n">child_dic</span><span class="p">[</span><span class="s1">&#39;(n,t)t&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;10030&#39;</span>
            
                <span class="k">elif</span> <span class="n">zamid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">30060</span><span class="p">,</span> <span class="mi">50100</span><span class="p">]:</span>
                    <span class="k">continue</span>

                <span class="c1"># Note that after that, Li6 and Be10 are still being added the other child from (n,t), as below</span>

            <span class="n">child_zamid</span> <span class="o">=</span> <span class="n">zamid</span> <span class="o">+</span> <span class="mi">10000</span><span class="o">*</span><span class="n">xs_prod_from_dic</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span> <span class="mi">10</span><span class="o">*</span><span class="n">xs_prod_from_dic</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">xs_prod_from_dic</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">child_dic</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">child_zamid</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_xs_child</span> <span class="o">=</span> <span class="n">child_dic</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">decay_child</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the daughter products of the nuclide via decay reactions&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decay_child</span>

    <span class="k">def</span> <span class="nf">_set_decaychild</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">zamid</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_zamid</span><span class="p">)</span>

        <span class="n">decay_prod_from_dic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_decay_prod_from_dic</span><span class="p">()</span>
        
        <span class="n">child_dic</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">decay_prod_from_dic</span><span class="p">:</span>
            <span class="n">child_zamid</span> <span class="o">=</span> <span class="n">zamid</span> <span class="o">+</span> <span class="mi">10000</span><span class="o">*</span><span class="n">decay_prod_from_dic</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span> <span class="mi">10</span><span class="o">*</span><span class="n">decay_prod_from_dic</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">decay_prod_from_dic</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">child_dic</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">child_zamid</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_decay_child</span> <span class="o">=</span> <span class="n">child_dic</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xs_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the parents of the nuclide via neutron-induced reactions&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xs_parent</span>

    <span class="k">def</span> <span class="nf">_set_xsparent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">zamid</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_zamid</span><span class="p">)</span>

        <span class="n">parent_dic</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">xs_prod_to_dic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_xs_prod_to_dic</span><span class="p">()</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xs_prod_to_dic</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="s1">&#39;(n,t)&#39;</span><span class="p">:</span>

                <span class="c1"># If nuclide is not a possible children of (n,t) reaction of Li6 or Be10</span>
                <span class="c1"># Skip</span>
                <span class="k">if</span> <span class="n">zamid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">10030</span><span class="p">,</span><span class="mi">20040</span><span class="p">,</span> <span class="mi">30070</span><span class="p">]:</span>
                    <span class="k">continue</span>

                <span class="c1"># In the case of tritium itself, the nuclide has two parents from the same type</span>
                <span class="c1"># of reaction (Li6 and Be10 from (n,t))</span>
                <span class="c1"># Therefore, we branched out this channel into two new channels</span>
                <span class="c1"># Note that ONIX should not try to find a parent for tritium through xs_prod_to_dic in this case</span>
                <span class="c1"># It would track back to Helium5 (He5 +n = H3 + H3)), which itself has no (n,t) reaction allocated</span>
                <span class="k">if</span> <span class="n">zamid</span> <span class="o">==</span> <span class="mi">10030</span><span class="p">:</span>
                    <span class="n">parent_dic</span><span class="p">[</span><span class="s1">&#39;Li6(n,t)&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;30060&#39;</span>
                    <span class="n">parent_dic</span><span class="p">[</span><span class="s1">&#39;Be10(n,t)&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;50100&#39;</span>
                    <span class="k">continue</span>

                <span class="c1"># This leaves us with only He4 and Li7 who are the products of Li6 (n,t) and Be10 (n,t) respectively</span>
                <span class="c1"># For these two nuclides, ONIX finds the parents through xs_prod_to_dict as below</span>

            <span class="n">parent_zamid</span> <span class="o">=</span> <span class="n">zamid</span> <span class="o">-</span> <span class="mi">10000</span><span class="o">*</span><span class="n">xs_prod_to_dic</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span> <span class="mi">10</span><span class="o">*</span><span class="n">xs_prod_to_dic</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">xs_prod_to_dic</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">parent_dic</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">parent_zamid</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_xs_parent</span> <span class="o">=</span> <span class="n">parent_dic</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">decay_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the parents of the nuclide via decay reactions&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decay_parent</span>

    <span class="k">def</span> <span class="nf">_set_decayparent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">zamid</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_zamid</span><span class="p">)</span>
        
        <span class="n">parent_dic</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">decay_prod_to_dic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_decay_prod_to_dic</span><span class="p">()</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">decay_prod_to_dic</span><span class="p">:</span>
            <span class="n">parent_zamid</span> <span class="o">=</span> <span class="n">zamid</span> <span class="o">-</span> <span class="mi">10000</span><span class="o">*</span><span class="n">decay_prod_to_dic</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span> <span class="mi">10</span><span class="o">*</span><span class="n">decay_prod_to_dic</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">decay_prod_to_dic</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">parent_dic</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">parent_zamid</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_decay_parent</span> <span class="o">=</span> <span class="n">parent_dic</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">all_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns all parents of the nuclide&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_parent</span>

    <span class="k">def</span> <span class="nf">_set_all_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">xs_parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xs_parent</span>
        <span class="n">decay_parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decay_parent</span>
        <span class="n">parent_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xs_parent</span><span class="p">:</span>
            <span class="n">parent_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xs_parent</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">decay_parent</span><span class="p">:</span>
            <span class="n">parent_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">decay_parent</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_all_parent</span> <span class="o">=</span> <span class="n">parent_list</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">all_child</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns all daughter products of the nuclide.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_child</span>

    <span class="k">def</span> <span class="nf">_set_all_child</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">xs_child</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xs_child</span>
        <span class="n">decay_child</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decay_child</span>
        <span class="n">child_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xs_child</span><span class="p">:</span>
            <span class="n">child_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xs_child</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">decay_child</span><span class="p">:</span>
            <span class="n">child_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">decay_child</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_all_child</span> <span class="o">=</span> <span class="n">child_list</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fission_child</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns daughter products of the nuclide via fission reactions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fission_child</span>

    <span class="nd">@fission_child</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">_fission_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fission_child</span><span class="p">):</span>


        <span class="c1"># I am not sure why I set this error</span>
        <span class="c1"># If the parent has no cross section, it is ok to still list its fission child</span>
        <span class="c1"># if self._current_xs == None:</span>
        <span class="c1">#     raise XS_not_yet_set(&quot;{} has no cross-sections yet&quot;.format(self._zamid))</span>

        <span class="c1"># Same here. Might not be important</span>
        <span class="c1"># if &#39;fission&#39; not in self._current_xs:</span>
        <span class="c1">#     raise No_fission_XS(&quot;{} has no fission cross-sections&quot;.format(self._zamid))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_fission_child</span> <span class="o">=</span> <span class="n">fission_child</span>


    <span class="c1"># Non0 parent and child are only the relatives when the reaction that link them to the nuclide is non-zero</span>

    <span class="c1"># def get_all_non0_parent(self):</span>

    <span class="c1">#     xs_parent = self._xs_parent</span>
    <span class="c1">#     decay_parent = self._decay_parent</span>
    <span class="c1">#     parent_list = []</span>

    <span class="c1">#     for i in xs_parent:</span>
    <span class="c1">#         parent_list.append(xs_parent[i])</span>
    <span class="c1">#     for i in decay_parent:</span>
    <span class="c1">#         parent_list.append(decay_parent[i])</span>

    <span class="c1">#     return parent_list</span>

    <span class="c1"># @property</span>
    <span class="c1"># def all__non0_parent(self):</span>

    <span class="c1">#     return self._all_parent</span>

    <span class="c1"># On the fly calculation</span>
<div class="viewcode-block" id="Passport.get_all_non0_child"><a class="viewcode-back" href="../../pythonapi/generated/onix.Passport.html#onix.Passport.get_all_non0_child">[docs]</a>    <span class="k">def</span> <span class="nf">get_all_non0_child</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets all daughter products of the nuclide produced via reactions that are non-zero (i.e., the reaction cross section or decay constant is not null) in the library used in the simulation&quot;&quot;&quot;</span>
        <span class="n">xs_child</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xs_child</span>
        <span class="n">decay_child</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decay_child</span>
        <span class="n">non0_child_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">xs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_xs</span>
        <span class="n">decay_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decay_a</span>
        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span>

        <span class="k">if</span> <span class="n">xs</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xs_child</span><span class="p">:</span>
                <span class="c1"># If this is an excited state, you need to remove the X at the beginning of the reaction name</span>
                <span class="k">if</span> <span class="n">state</span> <span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="k">elif</span> <span class="n">state</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">i</span>
                <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">xs</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">non0_child_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xs_child</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">decay_a</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">decay_child</span><span class="p">:</span>
                <span class="c1"># If this is an excited state, you need to remove the X at the beginning of the reaction _name</span>
                <span class="k">if</span> <span class="n">state</span> <span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="k">elif</span> <span class="n">state</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">i</span>
                <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">decay_a</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">decay_a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">non0_child_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">decay_child</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">non0_child_list</span></div>

    <span class="c1"># On the fly calculation since an AVT can become a FP if fy is set</span>
<div class="viewcode-block" id="Passport.get_FAM"><a class="viewcode-back" href="../../pythonapi/generated/onix.Passport.html#onix.Passport.get_FAM">[docs]</a>    <span class="k">def</span> <span class="nf">get_FAM</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the family of a nuclide (AVT= Activation, FP= Fission Product, ACT= Actinide)&quot;&quot;&quot;</span>

        <span class="n">nz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_z</span>

        <span class="n">FAM</span> <span class="o">=</span> <span class="s1">&#39;AVT&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fy</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">FAM</span> <span class="o">=</span> <span class="s1">&#39;FP&#39;</span>
        <span class="k">elif</span> <span class="n">nz</span> <span class="o">&gt;</span> <span class="mi">89</span><span class="p">:</span>
            <span class="n">FAM</span><span class="o">=</span> <span class="s1">&#39;ACT&#39;</span>

        <span class="k">return</span> <span class="n">FAM</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">get_a</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the mass number of the nuclide&quot;&quot;&quot;</span>
        <span class="n">zaid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zamid</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">zaid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">zaid</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">zaid</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">a</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">get_z</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the atomic number of the nuclide&quot;&quot;&quot;</span>
        <span class="n">zaid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zamid</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">zaid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">zaid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">zaid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">z</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the excitation state of the nuclide (excited or ground state)&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span>

    <span class="k">def</span> <span class="nf">_set_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the excitation state of the nuclide (excited or ground state)&quot;&quot;&quot;</span>
        <span class="n">zamid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zamid</span>
        <span class="n">state</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">zamid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">_get_id_input_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nuc_id</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">fct</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">nuc_id</span><span class="p">)</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">id_type</span> <span class="o">=</span> <span class="s1">&#39;zamid&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">id_type</span> <span class="o">=</span> <span class="s1">&#39;name&#39;</span>

        <span class="k">return</span> <span class="n">id_type</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fission_E</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the fission energy of the nuclide&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fission_E</span>

    <span class="nd">@fission_E</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">fission_E</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fission_E</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the fission energy of the nuclide&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fission_E</span> <span class="o">=</span> <span class="n">fission_E</span>

    <span class="k">def</span> <span class="nf">_set_energy_per_fission</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_a</span>
        <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_z</span>
        <span class="n">fission_E</span> <span class="o">=</span> <span class="mf">1.29927e-3</span><span class="o">*</span><span class="p">(</span><span class="n">z</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">+</span> <span class="mf">33.12</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_fission_E</span> <span class="o">=</span> <span class="n">fission_E</span>

<div class="viewcode-block" id="Passport.get_natural_abundance"><a class="viewcode-back" href="../../pythonapi/generated/onix.Passport.html#onix.Passport.get_natural_abundance">[docs]</a>    <span class="k">def</span> <span class="nf">get_natural_abundance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets the natural abundance of the nuclide normalized to 1 (value between 0 and 1)&quot;&quot;&quot;</span>
        <span class="n">name_new_format</span> <span class="o">=</span> <span class="n">fct</span><span class="o">.</span><span class="n">onix_name_to_openmc_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">nat_abun_dict</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">NATURAL_ABUNDANCE</span>
        <span class="k">if</span> <span class="n">name_new_format</span> <span class="ow">in</span> <span class="n">nat_abun_dict</span><span class="p">:</span>
            <span class="n">nat_abun</span> <span class="o">=</span> <span class="n">nat_abun_dict</span><span class="p">[</span><span class="n">name_new_format</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nat_abun</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">return</span> <span class="n">nat_abun</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">destruction_dic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a dictionnary of all the destruction terms of the nuclide.</span>

<span class="sd">        The keys are the reactions&#39; names</span>
<span class="sd">        The entries are the reaction rates of the reactions in :math:`barn^{-1}cm^{-1}s^{-1}`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_destruction_dic</span>

    <span class="nd">@destruction_dic</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">_destruction_dic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">destruction_dic</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets a dictionnary of all the destruction terms of the nuclide&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_destruction_dic</span> <span class="o">=</span> <span class="n">destruction_dic</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">creation_dic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a dictionnary of all the production terms of the nuclide.</span>

<span class="sd">        The keys are the parent nuclides&#39; names with the reaction in parenthesis</span>
<span class="sd">        The entries are the reaction rates of the reactions in :math:`barn^{-1}cm^{-1}s^{-1}`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_creation_dic</span>

    <span class="nd">@creation_dic</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">_creation_dic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">creation_dic</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_creation_dic</span> <span class="o">=</span> <span class="n">creation_dic</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">allreacs_dic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns an aggregated dictionnary with production and destruction terms of the nuclide&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_allreacs_dic</span>

    <span class="nd">@allreacs_dic</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">_allreacs_dic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">allreacs_dic</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_allreacs_dic</span> <span class="o">=</span> <span class="n">allreacs_dic</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">allreacs_dic_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of aggregated dictionnaries with production and destruction terms of the nuclide. One dictionnary per microstep&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_allreacs_dic_list</span>

    <span class="k">def</span> <span class="nf">_allreacs_dic_list_append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">allreacs_dic</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_allreacs_dic_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">allreacs_dic</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">current_sorted_allreacs_tuple_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_sorted_allreacs_tuple_list</span>

    <span class="k">def</span> <span class="nf">_append_current_sorted_allreacs_tuple_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sorted_allreacs</span><span class="p">,</span> <span class="n">ss</span><span class="p">):</span>

        <span class="c1"># If this is the beginning of a new step</span>
        <span class="k">if</span> <span class="n">ss</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_sorted_allreacs_tuple_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_current_sorted_allreacs_tuple_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sorted_allreacs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sorted_allreacs_tuple_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of tuples that contains destruction and production terms</span>

<span class="sd">        For destruction terms, the first element is the reaction name and the second element</span>
<span class="sd">        is the reaction rate in :math:`barn^{-1}cm^{-1}s^{-1}`</span>
<span class="sd">        For production terms, the first element is the parent nuclide witht the reaction name in parenthesis</span>
<span class="sd">        and the second element is the reactio rate in :math:`barn^{-1}cm^{-1}s^{-1}`</span>
<span class="sd">        These tuples are ranked from lower reaction rate to higher reaction rate&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sorted_allreacs_tuple_mat</span>

    <span class="k">def</span> <span class="nf">_append_sorted_allreacs_tuple_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_sorted_allreacs_tuple_mat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_sorted_allreacs_tuple_list</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pikachu</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="k">return</span> <span class="s1">&#39;PIKA PIKA!&#39;</span></div>


<span class="k">class</span> <span class="nc">Incorrect_nuc_id</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raise when the id input format in passport instantiation is incorrect&quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Nuc_xs_not_found</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raise when the user requests a cross-sections of a nuclide that is not in the nuclide set &quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Not_a_Fission_Product</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raise when the user tries to set fission yields for a non fission product nuclide &quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">XS_not_yet_set</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raise when the user tries to access XS for a nuclide which XS have not been set yet &quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">No_fission_XS</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raise when the user tries to access fission XS for a nuclide which fission XS have not been set yet &quot;&quot;&quot;</span>
    <span class="k">pass</span>





















































</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Julien de Troullioud de Lanversin

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
 
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-30411614-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>


</body>
</html>